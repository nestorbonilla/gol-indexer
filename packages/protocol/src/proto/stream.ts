// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               unknown
// source: stream.proto

/* eslint-disable */
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import _m0 from "protobufjs/minimal.js";
import { Duration } from "./google/protobuf/duration.js";

export const protobufPackage = "dna.v2.stream";

/** Apibara DNA server V2 */

/** Data finality. */
export enum DataFinality {
  UNKNOWN = 0,
  /** PENDING - Data was received, but is not part of the canonical chain yet. */
  PENDING = 1,
  /** ACCEPTED - Data is now part of the canonical chain, but could still be invalidated. */
  ACCEPTED = 2,
  /** FINALIZED - Data is finalized and cannot be invalidated. */
  FINALIZED = 3,
  UNRECOGNIZED = -1,
}

export function dataFinalityFromJSON(object: any): DataFinality {
  switch (object) {
    case 0:
    case "DATA_FINALITY_UNKNOWN":
      return DataFinality.UNKNOWN;
    case 1:
    case "DATA_FINALITY_PENDING":
      return DataFinality.PENDING;
    case 2:
    case "DATA_FINALITY_ACCEPTED":
      return DataFinality.ACCEPTED;
    case 3:
    case "DATA_FINALITY_FINALIZED":
      return DataFinality.FINALIZED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataFinality.UNRECOGNIZED;
  }
}

export function dataFinalityToJSON(object: DataFinality): string {
  switch (object) {
    case DataFinality.UNKNOWN:
      return "DATA_FINALITY_UNKNOWN";
    case DataFinality.PENDING:
      return "DATA_FINALITY_PENDING";
    case DataFinality.ACCEPTED:
      return "DATA_FINALITY_ACCEPTED";
    case DataFinality.FINALIZED:
      return "DATA_FINALITY_FINALIZED";
    case DataFinality.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Data production mode. */
export enum DataProduction {
  UNKNOWN = 0,
  /** BACKFILL - Data is for a backfilled block. */
  BACKFILL = 1,
  /** LIVE - Data is for a live block. */
  LIVE = 2,
  UNRECOGNIZED = -1,
}

export function dataProductionFromJSON(object: any): DataProduction {
  switch (object) {
    case 0:
    case "DATA_PRODUCTION_UNKNOWN":
      return DataProduction.UNKNOWN;
    case 1:
    case "DATA_PRODUCTION_BACKFILL":
      return DataProduction.BACKFILL;
    case 2:
    case "DATA_PRODUCTION_LIVE":
      return DataProduction.LIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataProduction.UNRECOGNIZED;
  }
}

export function dataProductionToJSON(object: DataProduction): string {
  switch (object) {
    case DataProduction.UNKNOWN:
      return "DATA_PRODUCTION_UNKNOWN";
    case DataProduction.BACKFILL:
      return "DATA_PRODUCTION_BACKFILL";
    case DataProduction.LIVE:
      return "DATA_PRODUCTION_LIVE";
    case DataProduction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A cursor over the stream content. */
export interface Cursor {
  /**
   * Key used for ordering messages in the stream.
   *
   * This is usually the block or slot number.
   */
  readonly orderKey: bigint;
  /**
   * Key used to discriminate branches in the stream.
   *
   * This is usually the hash of the block.
   */
  readonly uniqueKey: Uint8Array;
}

/** Request for the `Status` method. */
export interface StatusRequest {
}

/** Response for the `Status` method. */
export interface StatusResponse {
  /** The current head of the chain. */
  readonly currentHead?:
    | Cursor
    | undefined;
  /** The last cursor that was ingested by the node. */
  readonly lastIngested?:
    | Cursor
    | undefined;
  /** The finalized block. */
  readonly finalized?:
    | Cursor
    | undefined;
  /** The first block available. */
  readonly starting?: Cursor | undefined;
}

/** Request data to be streamed. */
export interface StreamDataRequest {
  /**
   * Cursor to start streaming from.
   *
   * If not specified, starts from the genesis block.
   * Use the data's message `end_cursor` field to resume streaming.
   */
  readonly startingCursor?:
    | Cursor
    | undefined;
  /**
   * Return data with the specified finality.
   *
   * If not specified, defaults to `DATA_FINALITY_ACCEPTED`.
   */
  readonly finality?:
    | DataFinality
    | undefined;
  /** Filters used to generate data. */
  readonly filter: readonly Uint8Array[];
  /**
   * Heartbeat interval.
   *
   * Value must be between 10 and 60 seconds.
   * If not specified, defaults to 30 seconds.
   */
  readonly heartbeatInterval?: Duration | undefined;
}

/** Contains a piece of streamed data. */
export interface StreamDataResponse {
  readonly message?:
    | { readonly $case: "data"; readonly data: Data }
    | { readonly $case: "invalidate"; readonly invalidate: Invalidate }
    | { readonly $case: "finalize"; readonly finalize: Finalize }
    | { readonly $case: "heartbeat"; readonly heartbeat: Heartbeat }
    | { readonly $case: "systemMessage"; readonly systemMessage: SystemMessage }
    | undefined;
}

/** Invalidate data after the given cursor. */
export interface Invalidate {
  /**
   * The cursor of the new chain's head.
   *
   * All data after this cursor should be considered invalid.
   */
  readonly cursor?:
    | Cursor
    | undefined;
  /** List of blocks that were removed from the chain. */
  readonly removed: readonly Cursor[];
}

/** Move the finalized block forward. */
export interface Finalize {
  /**
   * The cursor of the new finalized block.
   *
   * All data before this cursor cannot be invalidated.
   */
  readonly cursor?: Cursor | undefined;
}

/**
 * A single block of data.
 *
 * If the request specified multiple filters, the `data` field will contain the
 * data for each filter in the same order as the filters were specified in the
 * request.
 * If no data is available for a filter, the corresponding data field will be
 * empty.
 */
export interface Data {
  /** Cursor that generated this block of data. */
  readonly cursor?:
    | Cursor
    | undefined;
  /** Block cursor. Use this cursor to resume the stream. */
  readonly endCursor?:
    | Cursor
    | undefined;
  /** The finality status of the block. */
  readonly finality: DataFinality;
  /**
   * The block data.
   *
   * This message contains chain-specific data serialized using protobuf.
   */
  readonly data: readonly Uint8Array[];
  /** The production mode of the block. */
  readonly production: DataProduction;
}

/** Sent to clients to check if stream is still connected. */
export interface Heartbeat {
}

/** Message from the server to the client. */
export interface SystemMessage {
  readonly output?: { readonly $case: "stdout"; readonly stdout: string } | {
    readonly $case: "stderr";
    readonly stderr: string;
  } | undefined;
}

function createBaseCursor(): Cursor {
  return { orderKey: BigInt("0"), uniqueKey: new Uint8Array(0) };
}

export const Cursor = {
  encode(message: Cursor, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderKey !== BigInt("0")) {
      if (BigInt.asUintN(64, message.orderKey) !== message.orderKey) {
        throw new globalThis.Error("value provided for field message.orderKey of type uint64 too large");
      }
      writer.uint32(8).uint64(message.orderKey.toString());
    }
    if (message.uniqueKey.length !== 0) {
      writer.uint32(18).bytes(message.uniqueKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Cursor {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCursor() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.orderKey = longToBigint(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uniqueKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cursor {
    return {
      orderKey: isSet(object.orderKey) ? BigInt(object.orderKey) : BigInt("0"),
      uniqueKey: isSet(object.uniqueKey) ? bytesFromBase64(object.uniqueKey) : new Uint8Array(0),
    };
  },

  toJSON(message: Cursor): unknown {
    const obj: any = {};
    if (message.orderKey !== BigInt("0")) {
      obj.orderKey = message.orderKey.toString();
    }
    if (message.uniqueKey.length !== 0) {
      obj.uniqueKey = base64FromBytes(message.uniqueKey);
    }
    return obj;
  },

  create(base?: DeepPartial<Cursor>): Cursor {
    return Cursor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cursor>): Cursor {
    const message = createBaseCursor() as any;
    message.orderKey = object.orderKey ?? BigInt("0");
    message.uniqueKey = object.uniqueKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseStatusRequest(): StatusRequest {
  return {};
}

export const StatusRequest = {
  encode(_: StatusRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StatusRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StatusRequest {
    return {};
  },

  toJSON(_: StatusRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<StatusRequest>): StatusRequest {
    return StatusRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<StatusRequest>): StatusRequest {
    const message = createBaseStatusRequest() as any;
    return message;
  },
};

function createBaseStatusResponse(): StatusResponse {
  return { currentHead: undefined, lastIngested: undefined, finalized: undefined, starting: undefined };
}

export const StatusResponse = {
  encode(message: StatusResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currentHead !== undefined) {
      Cursor.encode(message.currentHead, writer.uint32(10).fork()).ldelim();
    }
    if (message.lastIngested !== undefined) {
      Cursor.encode(message.lastIngested, writer.uint32(18).fork()).ldelim();
    }
    if (message.finalized !== undefined) {
      Cursor.encode(message.finalized, writer.uint32(26).fork()).ldelim();
    }
    if (message.starting !== undefined) {
      Cursor.encode(message.starting, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StatusResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currentHead = Cursor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lastIngested = Cursor.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.finalized = Cursor.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.starting = Cursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusResponse {
    return {
      currentHead: isSet(object.currentHead) ? Cursor.fromJSON(object.currentHead) : undefined,
      lastIngested: isSet(object.lastIngested) ? Cursor.fromJSON(object.lastIngested) : undefined,
      finalized: isSet(object.finalized) ? Cursor.fromJSON(object.finalized) : undefined,
      starting: isSet(object.starting) ? Cursor.fromJSON(object.starting) : undefined,
    };
  },

  toJSON(message: StatusResponse): unknown {
    const obj: any = {};
    if (message.currentHead !== undefined) {
      obj.currentHead = Cursor.toJSON(message.currentHead);
    }
    if (message.lastIngested !== undefined) {
      obj.lastIngested = Cursor.toJSON(message.lastIngested);
    }
    if (message.finalized !== undefined) {
      obj.finalized = Cursor.toJSON(message.finalized);
    }
    if (message.starting !== undefined) {
      obj.starting = Cursor.toJSON(message.starting);
    }
    return obj;
  },

  create(base?: DeepPartial<StatusResponse>): StatusResponse {
    return StatusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StatusResponse>): StatusResponse {
    const message = createBaseStatusResponse() as any;
    message.currentHead = (object.currentHead !== undefined && object.currentHead !== null)
      ? Cursor.fromPartial(object.currentHead)
      : undefined;
    message.lastIngested = (object.lastIngested !== undefined && object.lastIngested !== null)
      ? Cursor.fromPartial(object.lastIngested)
      : undefined;
    message.finalized = (object.finalized !== undefined && object.finalized !== null)
      ? Cursor.fromPartial(object.finalized)
      : undefined;
    message.starting = (object.starting !== undefined && object.starting !== null)
      ? Cursor.fromPartial(object.starting)
      : undefined;
    return message;
  },
};

function createBaseStreamDataRequest(): StreamDataRequest {
  return { startingCursor: undefined, finality: undefined, filter: [], heartbeatInterval: undefined };
}

export const StreamDataRequest = {
  encode(message: StreamDataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.startingCursor !== undefined) {
      Cursor.encode(message.startingCursor, writer.uint32(10).fork()).ldelim();
    }
    if (message.finality !== undefined) {
      writer.uint32(16).int32(message.finality);
    }
    for (const v of message.filter) {
      writer.uint32(26).bytes(v!);
    }
    if (message.heartbeatInterval !== undefined) {
      Duration.encode(message.heartbeatInterval, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamDataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamDataRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startingCursor = Cursor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.finality = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter.push(reader.bytes());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.heartbeatInterval = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamDataRequest {
    return {
      startingCursor: isSet(object.startingCursor) ? Cursor.fromJSON(object.startingCursor) : undefined,
      finality: isSet(object.finality) ? dataFinalityFromJSON(object.finality) : undefined,
      filter: globalThis.Array.isArray(object?.filter) ? object.filter.map((e: any) => bytesFromBase64(e)) : [],
      heartbeatInterval: isSet(object.heartbeatInterval) ? Duration.fromJSON(object.heartbeatInterval) : undefined,
    };
  },

  toJSON(message: StreamDataRequest): unknown {
    const obj: any = {};
    if (message.startingCursor !== undefined) {
      obj.startingCursor = Cursor.toJSON(message.startingCursor);
    }
    if (message.finality !== undefined) {
      obj.finality = dataFinalityToJSON(message.finality);
    }
    if (message.filter?.length) {
      obj.filter = message.filter.map((e) => base64FromBytes(e));
    }
    if (message.heartbeatInterval !== undefined) {
      obj.heartbeatInterval = Duration.toJSON(message.heartbeatInterval);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamDataRequest>): StreamDataRequest {
    return StreamDataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamDataRequest>): StreamDataRequest {
    const message = createBaseStreamDataRequest() as any;
    message.startingCursor = (object.startingCursor !== undefined && object.startingCursor !== null)
      ? Cursor.fromPartial(object.startingCursor)
      : undefined;
    message.finality = object.finality ?? undefined;
    message.filter = object.filter?.map((e) => e) || [];
    message.heartbeatInterval = (object.heartbeatInterval !== undefined && object.heartbeatInterval !== null)
      ? Duration.fromPartial(object.heartbeatInterval)
      : undefined;
    return message;
  },
};

function createBaseStreamDataResponse(): StreamDataResponse {
  return { message: undefined };
}

export const StreamDataResponse = {
  encode(message: StreamDataResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.message?.$case) {
      case "data":
        Data.encode(message.message.data, writer.uint32(10).fork()).ldelim();
        break;
      case "invalidate":
        Invalidate.encode(message.message.invalidate, writer.uint32(18).fork()).ldelim();
        break;
      case "finalize":
        Finalize.encode(message.message.finalize, writer.uint32(26).fork()).ldelim();
        break;
      case "heartbeat":
        Heartbeat.encode(message.message.heartbeat, writer.uint32(34).fork()).ldelim();
        break;
      case "systemMessage":
        SystemMessage.encode(message.message.systemMessage, writer.uint32(42).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamDataResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamDataResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = { $case: "data", data: Data.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = { $case: "invalidate", invalidate: Invalidate.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = { $case: "finalize", finalize: Finalize.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message = { $case: "heartbeat", heartbeat: Heartbeat.decode(reader, reader.uint32()) };
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.message = { $case: "systemMessage", systemMessage: SystemMessage.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamDataResponse {
    return {
      message: isSet(object.data)
        ? { $case: "data", data: Data.fromJSON(object.data) }
        : isSet(object.invalidate)
        ? { $case: "invalidate", invalidate: Invalidate.fromJSON(object.invalidate) }
        : isSet(object.finalize)
        ? { $case: "finalize", finalize: Finalize.fromJSON(object.finalize) }
        : isSet(object.heartbeat)
        ? { $case: "heartbeat", heartbeat: Heartbeat.fromJSON(object.heartbeat) }
        : isSet(object.systemMessage)
        ? { $case: "systemMessage", systemMessage: SystemMessage.fromJSON(object.systemMessage) }
        : undefined,
    };
  },

  toJSON(message: StreamDataResponse): unknown {
    const obj: any = {};
    if (message.message?.$case === "data") {
      obj.data = Data.toJSON(message.message.data);
    }
    if (message.message?.$case === "invalidate") {
      obj.invalidate = Invalidate.toJSON(message.message.invalidate);
    }
    if (message.message?.$case === "finalize") {
      obj.finalize = Finalize.toJSON(message.message.finalize);
    }
    if (message.message?.$case === "heartbeat") {
      obj.heartbeat = Heartbeat.toJSON(message.message.heartbeat);
    }
    if (message.message?.$case === "systemMessage") {
      obj.systemMessage = SystemMessage.toJSON(message.message.systemMessage);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamDataResponse>): StreamDataResponse {
    return StreamDataResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamDataResponse>): StreamDataResponse {
    const message = createBaseStreamDataResponse() as any;
    if (object.message?.$case === "data" && object.message?.data !== undefined && object.message?.data !== null) {
      message.message = { $case: "data", data: Data.fromPartial(object.message.data) };
    }
    if (
      object.message?.$case === "invalidate" &&
      object.message?.invalidate !== undefined &&
      object.message?.invalidate !== null
    ) {
      message.message = { $case: "invalidate", invalidate: Invalidate.fromPartial(object.message.invalidate) };
    }
    if (
      object.message?.$case === "finalize" &&
      object.message?.finalize !== undefined &&
      object.message?.finalize !== null
    ) {
      message.message = { $case: "finalize", finalize: Finalize.fromPartial(object.message.finalize) };
    }
    if (
      object.message?.$case === "heartbeat" &&
      object.message?.heartbeat !== undefined &&
      object.message?.heartbeat !== null
    ) {
      message.message = { $case: "heartbeat", heartbeat: Heartbeat.fromPartial(object.message.heartbeat) };
    }
    if (
      object.message?.$case === "systemMessage" &&
      object.message?.systemMessage !== undefined &&
      object.message?.systemMessage !== null
    ) {
      message.message = {
        $case: "systemMessage",
        systemMessage: SystemMessage.fromPartial(object.message.systemMessage),
      };
    }
    return message;
  },
};

function createBaseInvalidate(): Invalidate {
  return { cursor: undefined, removed: [] };
}

export const Invalidate = {
  encode(message: Invalidate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.removed) {
      Cursor.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Invalidate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvalidate() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.removed.push(Cursor.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Invalidate {
    return {
      cursor: isSet(object.cursor) ? Cursor.fromJSON(object.cursor) : undefined,
      removed: globalThis.Array.isArray(object?.removed) ? object.removed.map((e: any) => Cursor.fromJSON(e)) : [],
    };
  },

  toJSON(message: Invalidate): unknown {
    const obj: any = {};
    if (message.cursor !== undefined) {
      obj.cursor = Cursor.toJSON(message.cursor);
    }
    if (message.removed?.length) {
      obj.removed = message.removed.map((e) => Cursor.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Invalidate>): Invalidate {
    return Invalidate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Invalidate>): Invalidate {
    const message = createBaseInvalidate() as any;
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    message.removed = object.removed?.map((e) => Cursor.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFinalize(): Finalize {
  return { cursor: undefined };
}

export const Finalize = {
  encode(message: Finalize, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Finalize {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalize() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Finalize {
    return { cursor: isSet(object.cursor) ? Cursor.fromJSON(object.cursor) : undefined };
  },

  toJSON(message: Finalize): unknown {
    const obj: any = {};
    if (message.cursor !== undefined) {
      obj.cursor = Cursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<Finalize>): Finalize {
    return Finalize.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Finalize>): Finalize {
    const message = createBaseFinalize() as any;
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseData(): Data {
  return { cursor: undefined, endCursor: undefined, finality: 0, data: [], production: 0 };
}

export const Data = {
  encode(message: Data, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(10).fork()).ldelim();
    }
    if (message.endCursor !== undefined) {
      Cursor.encode(message.endCursor, writer.uint32(18).fork()).ldelim();
    }
    if (message.finality !== 0) {
      writer.uint32(24).int32(message.finality);
    }
    for (const v of message.data) {
      writer.uint32(34).bytes(v!);
    }
    if (message.production !== 0) {
      writer.uint32(40).int32(message.production);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Data {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseData() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endCursor = Cursor.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.finality = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.data.push(reader.bytes());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.production = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Data {
    return {
      cursor: isSet(object.cursor) ? Cursor.fromJSON(object.cursor) : undefined,
      endCursor: isSet(object.endCursor) ? Cursor.fromJSON(object.endCursor) : undefined,
      finality: isSet(object.finality) ? dataFinalityFromJSON(object.finality) : 0,
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => bytesFromBase64(e)) : [],
      production: isSet(object.production) ? dataProductionFromJSON(object.production) : 0,
    };
  },

  toJSON(message: Data): unknown {
    const obj: any = {};
    if (message.cursor !== undefined) {
      obj.cursor = Cursor.toJSON(message.cursor);
    }
    if (message.endCursor !== undefined) {
      obj.endCursor = Cursor.toJSON(message.endCursor);
    }
    if (message.finality !== 0) {
      obj.finality = dataFinalityToJSON(message.finality);
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => base64FromBytes(e));
    }
    if (message.production !== 0) {
      obj.production = dataProductionToJSON(message.production);
    }
    return obj;
  },

  create(base?: DeepPartial<Data>): Data {
    return Data.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Data>): Data {
    const message = createBaseData() as any;
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    message.endCursor = (object.endCursor !== undefined && object.endCursor !== null)
      ? Cursor.fromPartial(object.endCursor)
      : undefined;
    message.finality = object.finality ?? 0;
    message.data = object.data?.map((e) => e) || [];
    message.production = object.production ?? 0;
    return message;
  },
};

function createBaseHeartbeat(): Heartbeat {
  return {};
}

export const Heartbeat = {
  encode(_: Heartbeat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Heartbeat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeat() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Heartbeat {
    return {};
  },

  toJSON(_: Heartbeat): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Heartbeat>): Heartbeat {
    return Heartbeat.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Heartbeat>): Heartbeat {
    const message = createBaseHeartbeat() as any;
    return message;
  },
};

function createBaseSystemMessage(): SystemMessage {
  return { output: undefined };
}

export const SystemMessage = {
  encode(message: SystemMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.output?.$case) {
      case "stdout":
        writer.uint32(10).string(message.output.stdout);
        break;
      case "stderr":
        writer.uint32(18).string(message.output.stderr);
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SystemMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemMessage() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.output = { $case: "stdout", stdout: reader.string() };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.output = { $case: "stderr", stderr: reader.string() };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemMessage {
    return {
      output: isSet(object.stdout)
        ? { $case: "stdout", stdout: globalThis.String(object.stdout) }
        : isSet(object.stderr)
        ? { $case: "stderr", stderr: globalThis.String(object.stderr) }
        : undefined,
    };
  },

  toJSON(message: SystemMessage): unknown {
    const obj: any = {};
    if (message.output?.$case === "stdout") {
      obj.stdout = message.output.stdout;
    }
    if (message.output?.$case === "stderr") {
      obj.stderr = message.output.stderr;
    }
    return obj;
  },

  create(base?: DeepPartial<SystemMessage>): SystemMessage {
    return SystemMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SystemMessage>): SystemMessage {
    const message = createBaseSystemMessage() as any;
    if (object.output?.$case === "stdout" && object.output?.stdout !== undefined && object.output?.stdout !== null) {
      message.output = { $case: "stdout", stdout: object.output.stdout };
    }
    if (object.output?.$case === "stderr" && object.output?.stderr !== undefined && object.output?.stderr !== null) {
      message.output = { $case: "stderr", stderr: object.output.stderr };
    }
    return message;
  },
};

export type DnaStreamDefinition = typeof DnaStreamDefinition;
export const DnaStreamDefinition = {
  name: "DnaStream",
  fullName: "dna.v2.stream.DnaStream",
  methods: {
    /** Stream data from the server. */
    streamData: {
      name: "StreamData",
      requestType: StreamDataRequest,
      requestStream: false,
      responseType: StreamDataResponse,
      responseStream: true,
      options: {},
    },
    /** Get DNA server status. */
    status: {
      name: "Status",
      requestType: StatusRequest,
      requestStream: false,
      responseType: StatusResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface DnaStreamServiceImplementation<CallContextExt = {}> {
  /** Stream data from the server. */
  streamData(
    request: StreamDataRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<StreamDataResponse>>;
  /** Get DNA server status. */
  status(request: StatusRequest, context: CallContext & CallContextExt): Promise<DeepPartial<StatusResponse>>;
}

export interface DnaStreamClient<CallOptionsExt = {}> {
  /** Stream data from the server. */
  streamData(
    request: DeepPartial<StreamDataRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<StreamDataResponse>;
  /** Get DNA server status. */
  status(request: DeepPartial<StatusRequest>, options?: CallOptions & CallOptionsExt): Promise<StatusResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { readonly $case: string }
    ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { readonly $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToBigint(long: Long) {
  return BigInt(long.toString());
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };
