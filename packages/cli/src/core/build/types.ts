import fsp from "node:fs/promises";
import type { Apibara } from "apibara/types";
import { dirname, join, resolve } from "pathe";
import { type JSValue, generateTypes, resolveSchema } from "untyped";
import { prettyPath } from "../path";

export async function writeTypes(apibara: Apibara) {
  // Check if the config file has a TypeScript extension so we assume it's a TypeScript project
  const isTypeScript = apibara.options._c12.configFile?.endsWith(".ts");

  if (!isTypeScript) {
    // If it's not a TypeScript project, we don't need to generate the types
    return;
  }

  const typesDir = resolve(apibara.options.buildDir, "types");

  const config = [
    "// Generated by apibara",
    `
declare module "apibara/types" {`,
    apibara.options.typescript.generateRuntimeConfigTypes
      ? generateTypes(
          await resolveSchema(
            Object.fromEntries(
              Object.entries(apibara.options.runtimeConfig),
            ) as Record<string, JSValue>,
          ),
          {
            interfaceName: "ApibaraRuntimeConfig",
            addExport: false,
            addDefaults: false,
            allowExtraKeys: false,
            indentation: 2,
          },
        )
      : "",
    "}",
    // Makes this a module for augmentation purposes
    "export type {};",
  ];

  const buildFiles: { path: string; contents: string }[] = [];

  buildFiles.push({
    path: join(typesDir, "apibara-config.d.ts"),
    contents: config.join("\n"),
  });

  await Promise.all(
    buildFiles.map(async (file) => {
      const _file = resolve(apibara.options.buildDir, file.path);
      await fsp.mkdir(dirname(_file), { recursive: true });
      await fsp.writeFile(_file, file.contents);
    }),
  );

  apibara.logger.success(`Types written to ${prettyPath(typesDir)}`);
}
